# Kiro 大请求超时完整诊断报告

**诊断日期**: 2025-12-30  
**诊断目标**: 解决 Claude Code + ProxyCast + Kiro 组合使用时的 `error decoding response body` 错误  
**诊断结论**: Kiro Free 账户对大请求有 ~65 秒处理超时限制

---

## 目录

1. [问题现象](#1-问题现象)
2. [诊断过程](#2-诊断过程)
3. [根因分析](#3-根因分析)
4. [配置探究](#4-配置探究)
5. [解决方案](#5-解决方案)
6. [附录](#6-附录)

---

## 1. 问题现象

### 1.1 错误表现

| 位置 | 错误信息 |
|-----|---------|
| Claude Code | `API Error: 500 {"error":{"message":"error decoding response body"}}` |
| ProxyCast 凭证池 | Kiro 凭证显示多次错误 |
| ProxyCast Flow Monitor | 请求状态 `Failed`，错误类型 `network` |

### 1.2 失败请求特征 (基于 Flow JSON 深度分析)

| 特征 | 值 | 说明 |
|-----|---|------|
| **Flow ID** | `2f3f7e8f-1432-4f9e-9708-ee9d8781ddeb` | 示例失败请求 |
| **模型** | `claude-opus-4-5` | Claude Opus 4.5 |
| **提供商** | `kiro` | AWS CodeWhisperer |
| **耗时** | **65.55 秒** | 超时断开 |
| **TTFB** | `-` (无首字节) | 服务端未开始响应 |
| **消息数量** | **37 条** | 巨大的上下文 |
| **max_tokens** | **21,333** | 期望大输出 |
| **请求体大小** | **416 KB** | 超大请求 |
| **stream** | `false` | 非流式请求 |

### 1.3 请求内容分析

1. **System Prompt**: ~62KB (被截断)
   - Claude Code 完整系统提示
   - 包含工具定义、环境信息、MCP 服务器配置等

2. **消息历史** (37 条):
   - 从之前超出上下文限制的会话继续
   - 包含复杂的 Methodology Extractor 任务
   - 多轮工具调用 (TodoWrite, Read, Write, Glob 等)
   - 完整的方法论文档生成任务

3. **任务内容**:
   - 用户请求对 151 个文件进行深度分析
   - 分片输出 V2 方法论文档 (Part 1-4)
   - 包含大量代码块和 TypeScript 定义

---

## 2. 诊断过程

### 2.1 初步检查

#### 检查 Kiro Token 有效期

```bash
cat ~/Library/Application\ Support/proxycast/credentials/kiro_*.json | \
  python3 -c "
import json,sys
from datetime import datetime, timezone
d = json.load(sys.stdin)
expires = d.get('expiresAt', '')
if expires:
    exp_time = datetime.fromisoformat(expires.replace('Z', '+00:00'))
    now = datetime.now(timezone.utc)
    remaining = (exp_time - now).total_seconds() / 60
    print(f'过期时间: {expires}')
    print(f'剩余时间: {remaining:.1f} 分钟')
"
```

#### 查看最近失败请求

```bash
sqlite3 ~/Library/Application\ Support/proxycast/flows/global_index.sqlite \
  "SELECT id, created_at, model, status, duration_ms FROM flow_index 
   WHERE status='Failed' ORDER BY created_at DESC LIMIT 5;"
```

### 2.2 直接 API 测试

测试 Kiro API 端点 `generateAssistantResponse`:

```bash
# 获取最新 Token
TOKEN_FILE=$(ls -t ~/Library/Application\ Support/proxycast/credentials/kiro_*.json | head -1)
ACCESS_TOKEN=$(cat "$TOKEN_FILE" | python3 -c "import json,sys; print(json.load(sys.stdin).get('accessToken',''))")

# 测试简单请求
curl -s -X POST \
  "https://codewhisperer.us-east-1.amazonaws.com/generateAssistantResponse" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -d '{
    "conversationState": {
      "chatTriggerType": "MANUAL", 
      "currentMessage": {
        "userInputMessage": {"content": "Hi"}
      }
    }
  }' -w "\n状态码: %{http_code}\n"
```

### 2.3 测试结果

| 测试类型 | 结果 | 说明 |
|---------|------|------|
| 简单请求 `"Hi"` | ✅ 200 OK | Kiro API 正常响应 |
| Claude Code 完整请求 (416KB) | ❌ 超时失败 | ~65秒后断开 |

---

## 3. 根因分析

### 3.1 错误传播链

```
Claude Code 发送大请求 (416KB, 37条消息)
    ↓
ProxyCast 接收并转发到 Kiro
    ↓
Kiro (AWS CodeWhisperer) 开始处理
    ↓
处理时间过长，~65秒后服务端超时
    ↓
连接断开，无响应体返回
    ↓
ProxyCast 尝试解析空响应 → 失败
    ↓
返回 "error decoding response body"
```

### 3.2 核心问题

**Kiro Free 账户对大请求有处理时间限制 (~65秒)**

- ✅ Kiro Token 有效
- ✅ Kiro API 端点正常
- ✅ ProxyCast 配置正确 (`request_timeout: 300s`)
- ❌ **Kiro 服务端无法在超时前处理完大请求**

### 3.3 为什么简单请求成功

简单请求（如 "Hi"）请求体很小，Kiro 可以快速处理并返回。  
复杂请求（416KB, 37条消息）需要更长处理时间，超出 Kiro 服务端限制。

---

## 4. 配置探究

### 4.1 ProxyCast 超时配置 (源代码分析)

| 文件 | 超时类型 | 值 |
|-----|---------|---|
| `client_factory.rs:90` | `request_timeout` | **300 秒 (5分钟)** |
| `client_factory.rs:89` | `connect_timeout` | 30 秒 |
| `interceptor.rs:70` | `default_timeout_ms` | 30 秒 (Flow 拦截) |
| `provider_pool_service.rs:47` | `health_check_timeout` | 30 秒 |

**结论**: ProxyCast 的 300 秒超时足够，问题不在这里。

### 4.2 ProxyCast 本地配置文件

**位置**: `~/Library/Application Support/proxycast/`

| 文件 | 是否有超时设置 |
|-----|--------------|
| `config.json` | ❌ 无 |
| `config.yaml` | ❌ 无 |

**结论**: 当前 ProxyCast 不暴露超时配置给用户修改。

### 4.3 Kiro 客户端配置探究

在 Kiro Settings 中搜索 `timeout` 和 `network`：

| 设置 | 值 | 用途 |
|-----|---|------|
| Files > Participants | 60000ms | 文件操作 |
| Application: Shell Environment | 10s | Shell 环境 |
| GitLens: Git Timeout | 60s | Git 命令 |
| Jupyter Launch Timeout | 60000ms | Jupyter 启动 |

**结论**: Kiro 客户端没有提供 AI 请求超时配置，超时由 AWS 服务端控制。

### 4.4 AWS 服务典型超时限制

| AWS 服务 | 默认超时 |
|---------|---------|
| API Gateway REST API | 29 秒 |
| API Gateway HTTP API | 30 秒 |
| Lambda 函数 | 15 分钟 (max) |
| **实际 Kiro 体验** | **~65 秒** |

---

## 5. 解决方案

### 5.1 紧急处理 (立即可用)

#### 减少请求体大小

```bash
# 在 Claude Code 中执行
/clear          # 清除所有上下文
/compact        # 压缩历史消息
```

**效果**: 将 37 条消息 → 几条消息，416KB → 几十KB

#### 避免大型生成任务

**问题案例**:
```
"使用最大的算力，最深入的思考，全面扫描151个文件..."
```

**改进方式**:
```
第1轮: "帮我分析目录结构和文件分类"
第2轮: "分析核心方法论文档 (前5个)"
第3轮: "分析规则文件 (16个 .mdc)"
...
```

### 5.2 Claude Code 使用技巧

#### 定期清理上下文

```bash
/clear    # 清除上下文
/compact  # 压缩历史
/cost     # 查看 token 消耗
```

**建议**: 每完成一个独立任务后执行 `/clear`

#### 分段式提问

❌ **错误做法**:
```
帮我分析这个项目的所有代码，然后重构整个认证模块，
同时优化数据库查询，最后添加单元测试
```

✅ **正确做法**:
```
第1步: 帮我分析认证模块的现有实现
(等待完成)

第2步: 基于分析，重构认证模块
(等待完成)

第3步: 添加单元测试
```

#### 减少同时打开的文件

Claude Code 会将打开的文件作为上下文发送：
- ✅ 只保留当前任务需要的文件
- ❌ 避免同时打开大量无关文件

#### 精简系统提示词

如果你有自定义的 `CLAUDE.md` 或 System Prompt：
- 保持精简，避免冗长的指令
- 使用简洁的规则描述
- 删除不常用的规则

### 5.3 针对 Kiro 的特殊建议

| 场景 | 建议 |
|-----|------|
| **新会话** | 从简单问题开始，逐步加深 |
| **复杂任务** | 拆分成多个小任务 |
| **超时后** | 立即 `/clear` 重新开始 |
| **大文件** | 使用 `@file` 引用而不是粘贴内容 |
| **长对话** | 定期使用 `/compact` 压缩历史 |

### 5.4 ProxyCast 配置建议

#### 使用多凭证轮换

在凭证池中添加多个 Kiro 账号：
- 实现自动故障转移
- 分散请求负载

#### 配置备用提供商

| 提供商 | 用途 |
|-------|------|
| **Kiro** | 简单/中等请求 |
| **Gemini** | 大请求备选 |
| **Claude API** | 付费稳定选项 |

#### ProxyCast 重试配置

当前设置（已确认可重试 500/504）：
- 最大重试次数: 滑块 1-10
- 基础延迟: 1000ms
- 最大延迟: 30000ms
- 可重试状态码: 408, 429, 500, 502, 503, 504

### 5.5 长期解决方案

#### 考虑 Kiro Pro 账户

| 特性 | Kiro Free | Kiro Pro (推测) |
|-----|-----------|----------------|
| 处理时间限制 | ~65 秒 | 可能更长 |
| 请求体大小 | 受限 | 可能更大 |
| 并发请求 | 受限 | 更多 |

#### 使用官方 API

如果需要稳定处理大请求，考虑使用：
- Anthropic Claude API (官方)
- OpenAI API
- Google Gemini API

这些官方 API 通常有更高的超时限制和更稳定的服务。

---

## 6. 附录

### 6.1 Claude Code 快速命令速查

| 命令 | 作用 |
|-----|------|
| `/clear` | 清除上下文 |
| `/compact` | 压缩历史 |
| `/cost` | 查看 token 消耗 |
| `/model` | 切换模型 |
| `/help` | 查看所有命令 |

### 6.2 诊断命令汇总

```bash
# 检查 Kiro Token 有效期
cat ~/Library/Application\ Support/proxycast/credentials/kiro_*.json | \
  python3 -c "import json,sys; from datetime import datetime,timezone; d=json.load(sys.stdin); \
  exp=datetime.fromisoformat(d.get('expiresAt','').replace('Z','+00:00')); \
  print(f'剩余: {(exp-datetime.now(timezone.utc)).total_seconds()/60:.1f}分钟')"

# 查看失败请求
sqlite3 ~/Library/Application\ Support/proxycast/flows/global_index.sqlite \
  "SELECT * FROM flow_index WHERE status='Failed' ORDER BY created_at DESC LIMIT 5;"

# 测试 ProxyCast 连通性
curl -s http://127.0.0.1:8999/healthz

# 测试简单 API 调用
curl -s -X POST http://127.0.0.1:8999/v1/messages \
  -H "Content-Type: application/json" \
  -H "x-api-key: pc_YOUR_API_KEY" \
  -H "anthropic-version: 2023-06-01" \
  -d '{"model":"claude-sonnet-4-5","max_tokens":10,"messages":[{"role":"user","content":"Hi"}]}'
```

### 6.3 相关文件位置

| 文件/目录 | 路径 |
|---------|------|
| ProxyCast 凭证 | `~/Library/Application Support/proxycast/credentials/` |
| ProxyCast 配置 | `~/Library/Application Support/proxycast/config.yaml` |
| ProxyCast Flow 日志 | `~/Library/Application Support/proxycast/flows/` |
| ProxyCast 源代码 | `/Users/ameureka/Desktop/ai_infra_ameureka/proxycast/proxycast/src-tauri/src/` |

### 6.4 关键源代码位置

| 文件 | 行号 | 内容 |
|-----|------|------|
| `client_factory.rs` | 90 | `request_timeout: Duration::from_secs(300)` |
| `client_factory.rs` | 89 | `connect_timeout: Duration::from_secs(30)` |
| `interceptor.rs` | 70 | `fn default_timeout_ms() -> u64 { 30000 }` |
| `provider_pool_service.rs` | 47 | `health_check_timeout: Duration::from_secs(30)` |

---

## 更新日志

- **2025-12-30**: 初始版本
  - 完成错误诊断和根因分析
  - 记录 ProxyCast 和 Kiro 配置探究
  - 整理解决方案和使用技巧
